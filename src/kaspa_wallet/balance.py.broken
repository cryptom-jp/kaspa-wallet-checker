#!/usr/bin/env python3
"""
Kaspa Wallet Balance Checker (gRPC版)
CLI実行 & ライブラリとしてのインポート両対応
"""

import sys
import os
import json
import logging
import time
from typing import Dict, Any
import yaml
import grpc

# protoファイルのインポート
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..', 'proto'))
import rpc_pb2
import rpc_pb2_grpc

# 設定ファイルパス
CONFIG_FILE = os.path.join(os.path.dirname(__file__), 'config.yaml')

# 設定読み込み
def load_config():
    """設定ファイル読み込み"""
    with open(CONFIG_FILE, 'r') as f:
        return yaml.safe_load(f)

config = load_config()

# ロギング設定
log_config = config['logging']
logging.basicConfig(
    level=getattr(logging, log_config['level']),
    format=log_config['format'],
    handlers=[
        logging.FileHandler(os.path.expanduser(log_config['file'])),
        logging.StreamHandler() if log_config['console'] else logging.NullHandler()
    ]
)
logger = logging.getLogger(__name__)

# カスタム例外
class KaspaWalletError(Exception):
    """基底例外"""
    pass

class AddressValidationError(KaspaWalletError):
    """アドレス検証エラー"""
    pass

class NodeConnectionError(KaspaWalletError):
    """ノード接続エラー"""
    pass

class BalanceRetrievalError(KaspaWalletError):
    """残高取得エラー"""
    pass

# アドレス検証
def validate_address(address: str) -> bool:
    """Kaspaアドレス検証"""
    validation = config['validation']
    
    if len(address) < validation['min_address_length']:
        raise AddressValidationError(f"Address too short: {len(address)} chars")
    
    if not any(address.startswith(prefix) for prefix in validation['allowed_prefixes']):
        raise AddressValidationError(f"Invalid prefix. Expected: {validation['allowed_prefixes']}")
    
    return True

# 残高取得関数（ライブラリ用）
def get_balance(address: str) -> Dict[str, Any]:
    """
    Kaspaアドレスの残高を取得
    
    Args:
        address: Kaspaアドレス
        
    Returns:
        dict: 残高情報
            - status: "success" or "error"
            - balance_sompi: 残高（sompi単位）
            - balance_kas: 残高（KAS単位）
            - address: アドレス
            - error: エラータイプ（エラー時）
            - message: メッセージ
    """
    logger.info(f"残高取得開始: {address}")
    
    try:
        # アドレス検証
        validate_address(address)
        
        # gRPC設定
        grpc_config = config['grpc']
        channel = grpc.insecure_channel(
            grpc_config['address'],
            options=[
                ('grpc.max_receive_message_length', grpc_config['max_receive_message_length']),
                ('grpc.max_send_message_length', grpc_config['max_send_message_length'])
            ]
        )
        stub = rpc_pb2_grpc.RPCStub(channel)
        
        # リトライ処理
        max_retries = grpc_config['max_retries']
        base_delay = grpc_config['base_delay']
        
        for attempt in range(max_retries):
            try:
                # 残高取得リクエスト
                request = rpc_pb2.GetBalanceByAddressRequestMessage(
                    address=address
                )
                
                response = stub.GetBalanceByAddress(
                    request,
                    timeout=grpc_config['timeout']
                )
                
                # 残高変換
                balance_sompi = response.balance
                balance_kas = balance_sompi / 100000000
                
                logger.info(f"残高取得成功: {address} = {balance_sompi} sompi")
                logger.info(f"処理完了: {address}")
                
                channel.close()
                
                return {
                    "status": "success",
                    "balance_sompi": balance_sompi,
                    "balance_kas": balance_kas,
                    "address": address
                }
                
            except grpc.RpcError as e:
                if e.code() == grpc.StatusCode.UNAVAILABLE:
                    logger.error(f"接続不可: {e.details()}")
                    
                    if attempt < max_retries - 1:
                        delay = base_delay * (2 ** attempt)
                        logger.warning(f"リトライ {attempt + 1}/{max_retries} - {delay}秒後に再試行: Node unavailable: {e.details()}")
                        time.sleep(delay)
                        continue
                    else:
                        logger.error(f"最大リトライ回数到達: Node unavailable: {e.details()}")
                        channel.close()
                        raise NodeConnectionError(f"Node unavailable: {e.details()}")
                else:
                    logger.error(f"gRPCエラー: {e.code()}: {e.details()}")
                    channel.close()
                    raise BalanceRetrievalError(f"Node error: {e.details()}")
        
    except AddressValidationError as e:
        logger.error(f"アドレス検証失敗: {e}")
        return {
            "status": "error",
            "error": "validation_failed",
            "message": str(e),
            "address": address
        }
    
    except NodeConnectionError as e:
        return {
            "status": "error",
            "error": "connection_failed",
            "message": str(e),
            "address": address
        }
    
    except BalanceRetrievalError as e:
        return {
            "status": "error",
            "error": "retrieval_failed",
            "message": str(e),
            "address": address
        }
    
    except Exception as e:
        logger.error(f"予期しないエラー: {e}")
        return {
            "status": "error",
            "error": "unknown",
            "message": str(e),
            "address": address
        }

# CLI実行
def main():
    """CLI実行時のメイン処理"""
    if len(sys.argv) != 2:
        print("使い方: python balance.py <kaspa_address>")
        sys.exit(1)
    
    address = sys.argv[1]
    result = get_balance(address)
    
    print(json.dumps(result, indent=2, ensure_ascii=False))
    
    if result['status'] != 'success':
        sys.exit(1)

if __name__ == '__main__':
    main()
